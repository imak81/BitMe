/*
 * File: app/controller/InvoiceController.js
 *
 * This file was generated by Sencha Architect version 2.2.3.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 4.2.x library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 4.2.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('Bdn.controller.InvoiceController', {
    extend: 'Ext.app.Controller',

    views: [
        'InvoicePanel'
    ],

    refs: [
        {
            ref: 'wdPayMe',
            selector: 'wdpayme'
        },
        {
            ref: 'plInvoice',
            selector: 'invoicepanel'
        }
    ],

    onWPaymentTakerBeforeRender: function(component, eOpts) {
        var me = this,
            plInvoice = this.getPlInvoice(),
            tdAmountPaid = plInvoice.queryById('tdAmountPaid'),
            lbAmount = plInvoice.queryById('lbAmount');

        // Connect Socket
        if(window.socket === undefined) socket = io.connect('http://127.0.0.1:3000');


        // Update exchange rate and adjust accordingly to USD
        socket.on('update_exchange_rate', function (data) {
            selfConfig.rate = data;

            lbAmount.setValue(parseFloat(tdAmountPaid.getValue()) * parseFloat(selfConfig.rate));
        });


        // Update Invoice Status where neccessary
        socket.on('update_invoice_status', function (data) {
            switch (data.status){
                case 'expired':
                me.application.fireEvent('invoiceexpired');
                break;
                case 'partiallypad':
                me.application.fireEvent('invoicepartiallypaid');
                break;
                case 'paid':
                me.application.fireEvent('invoicepaid');
                break;

                default:
            }
        });
    },

    onBtPayClick: function(button, e, eOpts) {
        var me = this,
            ninja = Ext.create('Bdn.view.WdPayMe');

        var lbStatus = ninja.queryById('lbStatus'),
            plSingleWallet = ninja.child('#pSingleWallet'),
            pImagePublic = plSingleWallet.child('#pPublic #qrcode_public');


        ninja.wallets = {};


        ninja.qrCode = {
            // determine which type number is big enough for the input text length
            getTypeNumber: function (text) {
                var lengthCalculation = text.length * 8 + 12; // length as calculated by the QRCode
                if (lengthCalculation < 72) { return 1; }
                else if (lengthCalculation < 128) { return 2; }
                else if (lengthCalculation < 208) { return 3; }
                else if (lengthCalculation < 288) { return 4; }
                else if (lengthCalculation < 368) { return 5; }
                else if (lengthCalculation < 480) { return 6; }
                else if (lengthCalculation < 528) { return 7; }
                else if (lengthCalculation < 688) { return 8; }
                else if (lengthCalculation < 800) { return 9; }
                else if (lengthCalculation < 976) { return 10; }
                return null;
            },

            createCanvas: function (text, sizeMultiplier) {
                sizeMultiplier = (sizeMultiplier === undefined) ? 2 : sizeMultiplier; // default 2
                // create the qrcode itself
                var typeNumber = ninja.qrCode.getTypeNumber(text);
                var qrcode = new QRCode(typeNumber, QRCode.ErrorCorrectLevel.H);
                qrcode.addData(text);
                qrcode.make();
                var width = qrcode.getModuleCount() * sizeMultiplier;
                var height = qrcode.getModuleCount() * sizeMultiplier;
                // create canvas element
                var canvas = document.createElement('canvas');
                var scale = 10.0;
                canvas.width = width * scale;
                canvas.height = height * scale;
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';
                var ctx = canvas.getContext('2d');
                ctx.scale(scale, scale);
                // compute tileW/tileH based on width/height
                var tileW = width / qrcode.getModuleCount();
                var tileH = height / qrcode.getModuleCount();
                // draw in the canvas
                for (var row = 0; row < qrcode.getModuleCount(); row++) {
                    for (var col = 0; col < qrcode.getModuleCount(); col++) {
                        ctx.fillStyle = qrcode.isDark(row, col) ? "#000000" : "#ffffff";
                        ctx.fillRect(col * tileW, row * tileH, tileW, tileH);
                    }
                }
                // return just built canvas
                return canvas;
            },

            // generate a QRCode and return it's representation as an Html table 
            createTableHtml: function (text) {
                var typeNumber = ninja.qrCode.getTypeNumber(text);
                var qr = new QRCode(typeNumber, QRCode.ErrorCorrectLevel.H);
                qr.addData(text);
                qr.make();
                var tableHtml = "<table class='qrcodetable'>";
                for (var r = 0; r < qr.getModuleCount(); r++) {
                    tableHtml += "<tr>";
                    for (var c = 0; c < qr.getModuleCount(); c++) {
                        if (qr.isDark(r, c)) {
                            tableHtml += "<td class='qrcodetddark'/>";
                        } else {
                            tableHtml += "<td class='qrcodetdlight'/>";
                        }
                    }
                    tableHtml += "</tr>";
                }
                tableHtml += "</table>";
                return tableHtml;
            },

            // show QRCodes with canvas OR table (IE8)
            // parameter: keyValuePair 
            // example: { "id1": "string1", "id2": "string2"}
            //		"id1" is the id of a div element where you want a QRCode inserted.
            //		"string1" is the string you want encoded into the QRCode.
            showQrCode: function (keyValuePair, sizeMultiplier) {
                for (var key in keyValuePair) {
                    var value = keyValuePair[key];
                    try {
                        var qrImg = plSingleWallet.queryById(key);
                        if (qrImg) {
                            qrImg.getEl().setHTML("");
                            qrImg.getEl().appendChild(ninja.qrCode.createCanvas('bitcoin:'+ value + ';amount:20.50', sizeMultiplier));
                        }

                    } catch (e) {
                        // for browsers that do not support canvas (IE8)
                        plSingleWallet.queryById(key).getEl().setHTML(ninja.qrCode.createTableHtml('bitcoin:'+ value + ',amount:20.50'));
                    }
                }
            }
        };




        me.getApplication().getWalletModel().load(0, {
            scope: this,
            params: {
                username: 'bit2le',
                amount: 4.25
            },
            success: function(record, operation) {
                // Show Payme windows right at the center
                ninja.center();

                ninja.show();

                // Start checking payment status
                socket.emit('check_invoice_status', {
                    bitaddress: record.data.bitcoinaddress,
                    username: 'bit2le',
                    totalamount: 4.25
                });


                // Show Bitcoin Address received from server
                var keyValuePair = {
                    "qrcode_public": record.data.bitcoinaddress,
                    "qrcode_private": ''
                };

                plSingleWallet.queryById('address_public').setText(record.data.bitcoinaddress);

                ninja.qrCode.showQrCode(keyValuePair, 4);

            },
            failure: function(record, operation) {
                if(operation.exception && operation.error !== undefined) {
                    Ext.Msg.alert('Error', operation.error);
                } else {
                    if(operation.request.proxy.reader.rawData.title !== undefined && operation.request.proxy.reader.rawData.message !== undefined) {
                        Ext.Msg.alert(operation.request.proxy.reader.rawData.title, operation.request.proxy.reader.rawData.message);
                    } else {
                        Ext.Msg.alert('Error', 'Unsuccessful operation. Please contact HelpDesk. TAC: YELLOW!');
                    }
                }
            }
        });
    },

    onBtCancelClick: function(button, e, eOpts) {
        var me = this,
            wd = button.up('window'),
            status = wd.queryById('lbStatus').getValue(),
            colorStatus = this.getPlInvoice().queryById('StatusColor');

        wd.close();

        switch(status) {    
            case 'Waiting':
            colorStatus.getEl().setStyle('backgroundColor','');
            break;
            case 'Exprired':
            colorStatus.getEl().setStyle('backgroundColor','red');
            break;
            case 'Partially Paid':
            colorStatus.getEl().setStyle('backgroundColor','orrange');
            break;
            case 'Invoice Paid':
            colorStatus.getEl().setStyle('backgroundColor','green');
            break;
            default:

        }

    },

    onTdAmountPaidChange: function(field, newValue, oldValue, eOpts) {
        var me = this,
            plInvoice = this.getPlInvoice(),
            lbAmount = plInvoice.queryById('lbAmount');

        lbAmount.setValue(parseFloat(newValue) * parseFloat(selfConfig.rate));
    },

    onInvoicePaid: function() {
        var me = this,
            wdPayMe = this.getWdPayMe(),
            btCancel = wdPayMe.queryById('btCancel'),
            lbStatus = wdPayMe.queryById('lbStatus');

        // Show invoice status update
        lbStatus.setValue('Invoice Paid');
        lbStatus.setFieldStyle('color:green');

        btCancel.setText('Done');
    },

    onInvoiceExpired: function() {
        var me = this,
            wdPayMe = this.getWdPayMe(),
            lbStatus = wdPayMe.queryById('lbStatus');

        // Show invoice status update
        lbStatus.setValue('Expired');
        lbStatus.setFieldStyle('color:red');
    },

    onInvoicePartiallPpaid: function() {
        var me = this,
            wdPayMe = this.getWdPayMe(),
            btCancel = wdPayMe.queryById('btCancel'),
            lbStatus = wdPayMe.queryById('lbStatus');

        // Show invoice status update
        lbStatus.setValue('Partially Paid');
        lbStatus.setFieldStyle('color:orange');

        btCancel.setText('Done');
    },

    init: function(application) {
        this.control({
            "invoicepanel": {
                beforerender: this.onWPaymentTakerBeforeRender
            },
            "invoicepanel #btPay": {
                click: this.onBtPayClick
            },
            "wdpayme #btCancel": {
                click: this.onBtCancelClick
            },
            "invoicepanel #tdAmountPaid": {
                change: this.onTdAmountPaidChange
            }
        });

        application.on({
            invoicepaid: {
                fn: this.onInvoicePaid,
                scope: this
            },
            invoiceexpired: {
                fn: this.onInvoiceExpired,
                scope: this
            },
            invoicepartiallypaid: {
                fn: this.onInvoicePartiallPpaid,
                scope: this
            }
        });
    }

});
